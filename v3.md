# Mitigating Docker Hub rate limitations and Crossplane package restrictions with registry proxies

## Situation ðŸ“Š

In early 2025, Docker Hub announced a significant policy change: free users would be limited to 10 image pulls per hour starting April 1st. This wasn't an April Fool's joke but a real constraint affecting developers worldwide.

Around the same time, Upbound revealed that free users could only pull the latest Crossplane package versions as of March 25th, preventing access to specific older versions that many workflows depend on.

For our Kubernetes-based environments with frequent scaling and spot instances, these policies spelled serious trouble. Our analysis indicated that clients would exceed these limitations almost immediately during standard operations:

- A cluster with 20 nodes requiring 5 images each = 100 pulls
- Node replacements resulting from spot instance recycling = additional pulls for new nodes
- CI/CD pipeline test executions = further pulls against the quota

While Docker Hub had not yet enforced their policy, it appeared to be an imminent change that could potentially disrupt critical infrastructure services.

## Task ðŸŽ¯

We identified several critical requirements that needed to be addressed:

1. Implement a solution to circumvent the newly imposed rate limitations from Docker Hub and Upbound
2. Ensure uninterrupted access to specific Crossplane package versions
3. Enhance resilience against external registry service disruptions
4. Develop a solution compatible with multi-cloud environments

Any proposed solution needed to maintain transparency to client applications and minimize operational overhead for our infrastructure teams.

## The Solution: Registry Proxies

Registry proxies act as intermediaries between your infrastructure and external image repositories. They cache images locally after the first pull, eliminating rate limits for subsequent requests. This provides three key benefits:

1. **Bypass rate limits** - All subsequent pulls come from your proxy, not directly from Docker Hub
2. **Improved resilience** - Your infrastructure continues working even during external registry outages
3. **Version preservation** - Access specific Crossplane package versions even after restrictions

### AWS ECR Pull-Through Cache Implementation

Amazon ECR's pull-through cache functionality was configured to automatically retrieve and store images from upstream registries upon initial request:

```terraform
# Initialize a secret to store Docker Hub authentication credentials
resource "aws_secretsmanager_secret" "docker_hub_creds" {
  name = "ecr-pullthroughcache/docker-hub"
}

# Store the Docker Hub authentication parameters
resource "aws_secretsmanager_secret_version" "docker_hub_creds_version" {
  secret_id     = aws_secretsmanager_secret.docker_hub_creds.id
  secret_string = jsonencode({
    username    = var.docker_hub_username
    accessToken = var.docker_hub_access_token
  })
}

# Establish the pull-through cache configuration
resource "aws_ecr_pull_through_cache_rule" "docker_hub" {
  ecr_repository_prefix = "docker-hub"
  upstream_registry_url = "registry-1.docker.io"
  credential_arn        = aws_secretsmanager_secret.docker_hub_creds.arn
}
```

### Google Artifact Registry Remote Repository Configuration

We implemented Google Cloud's Artifact Registry to establish remote repositories that function as proxies for Docker Hub:

```terraform
# Create a remote repository configuration in Google Artifact Registry
resource "google_artifact_registry_repository" "docker_hub_proxy" {
  location      = var.region
  repository_id = "docker-hub-proxy"
  format        = "DOCKER"
  mode          = "REMOTE_REPOSITORY"

  # Define the remote repository configuration for Docker Hub
  remote_repository_config {
    description = "Docker Hub proxy repository"
    docker_repository {
      public_repository = "DOCKER_HUB"
    }
    # Configure Docker Hub authentication credentials
    upstream_credentials {
      username               = var.docker_hub_username
      password_secret_version = google_secret_manager_secret.docker_hub_token.id
    }
  }
}
```

### 4. Kubernetes Manifest Updates

We modified our Helm charts to reference container images through our established proxies:

**AWS ECR reference format:**

```
<account-id>.dkr.ecr.<region>.amazonaws.com/docker-hub/nginx:latest
```

**Google Artifact Registry reference format:**

```
<region>-docker.pkg.dev/<project-id>/hub-proxy/nginx:latest
```

For Crossplane packages, we established equivalent proxy configurations and updated the package references accordingly. Behind the scenes, Crossplane packages are essentially OCI-compliant Docker images.

## Results âœ…

Our registry proxy implementation delivered several significant operational benefits:

1. **Rate limitation mitigation** - Kubernetes clusters now retrieve all container images through our proxy infrastructure, registering as a single pull against Docker Hub's quota regardless of the number of nodes requiring the image.

2. **Version accessibility preservation** - We maintained access to all used Crossplane package versions, allowing for more controlled and predictable upgrade processes.

3. **Enhanced service resilience** - During Docker Hub outages, our infrastructure continues to operate without any disruption.

4. **Performance optimization** - We observed a reduction in container initialization times due to image retrieval from proxy repositories.

The implementation required initial configuration effort across our clients' multi-cloud infrastructure, but has substantially improved operational reliability by eliminating external registry dependencies and rate limitations.
